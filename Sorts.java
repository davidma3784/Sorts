package student_classes;

import static student_collections.SList.*;
import student_collections.SList;

/**
 * Common location to contain the quicksort and mergesort routines. Note, you
 * will also create public methods that are required to support (implement)
 * these sorts, such as "append," "merge," and maybe others.
 * 
 * <h1>Important Considerations here!</h1> Please read through these carefully:
 * <ul>
 * <li>No iterative constructions should be used here.</li>
 * <li>No exception handling will be permitted.</li>
 * <li>Use the special "NULL" from the SList package in place of Java's
 * <code>null</code>, or, better, return the original argument if it has been
 * reduced to null.</li>
 * <li><b>DO NOT</B> import anything from java.util.* in this file.</li>
 * <li>Do not mess with the imports at the top of this file, or in the
 * StudentTests file.</li>
 * </ul>
 * 
 * @author UMD CS Department.
 *Yanzhuo Ma
 */
public class Sorts {
	/**
	 * adds list2 to the end of list 1 transforming it into a new list which it
	 * returns
	 * 
	 * @param list1
	 * @param list2
	 * @return SList
	 */
	public static <T> SList<T> append(SList<T> list1, SList<T> list2) {

		if (length(list1) == 0 && length(list2) == 0) {
			return null;
		}
		if (length(list1) == 0) {
			return list2;
		}
		if (length(list2) == 0) {
			return list1;
		} else {
			SList<T> newList = (SList<T>) SList.list(NULL);
			newList = reverse(list1, newList);
			list2 = reverse(newList, list2);
			return rest(list2);
		}
	}

	/**
	 * Returns a new list that contains the first pos elements of list. If the
	 * list has fewer than pos elements, an IllegalStateException is thrown.
	 * 
	 * @param list
	 * @param pos
	 * @return SList
	 */
	public static <T> SList<T> take(SList<T> list, int pos) {
		if (length(list) < pos) {
			throw new IllegalStateException();
		}
		SList<T> helper = (SList<T>) SList.list(NULL);
		helper = rest(helper);
		list = takeHelper(list, helper, pos);
		SList<T> newList = (SList<T>) SList.list(NULL);
		newList = rest(newList);
		newList = reverse(list, newList);
		return newList;
	}

	/**
	 * Takehelper recursively to determine which positions of the list to keep
	 * 
	 * @param list1
	 * @param list2
	 * @return SList
	 */
	public static <T> SList<T> takeHelper(SList<T> list1, SList<T> list2,
			int pos1) {
		if (pos1 == 0) {
			return list2;
		} else {
			list2 = cons(first(list1), list2);
			list1 = rest(list1);
			return takeHelper(list1, list2, --pos1);
		}
	}

	/**
	 * Returns a new list that contains the remaining pos elements of list. If
	 * the list has fewer elements than pos elements, an IllegalStateException
	 * if thrown. Note: <code>drop( someList, 0 )</code> returns the original
	 * list.
	 * 
	 * @param list
	 * @param pos
	 * @return SList
	 */
	public static <T> SList<T> drop(SList<T> list, int pos) {
		if (length(list) < pos) {
			throw new IllegalStateException();
		}
		list = dropHelper(list, pos);
		return list;
	}

	/**
	 * Drophelper finds up to which position to keep
	 * 
	 * @param list1
	 * @param pos1
	 * @return SList
	 */
	public static <T> SList<T> dropHelper(SList<T> list1, int pos1) {
		if (pos1 == 0) {
			return list1;
		} else {
			list1 = rest(list1);
			return dropHelper(list1, --pos1);
		}
	}

	/**
	 * Performs the classic "merge sort" by treating the empty list or the
	 * singleton list as already sorted and then recursively merging the results
	 * of reducing each sublist generated by a pivot.
	 * 
	 * @param list
	 * @return SList
	 */
	public static <T extends Comparable<T>> SList<T> mergeSort(SList<T> list) {
		if (length(list) == 1) {
			return list;
		}
		int half = length(list) / 2;
		SList first = SList.list(NULL);
		first = rest(first);
		SList second = SList.list(NULL);
		second = rest(second);
		first = mergeSort(take(list, length(list) / 2));
		second = mergeSort(drop(list, length(list) / 2));
		list = mergeHelper(first, second);
		return list;
	}

	/**
	 * mergeHelper recursively merges the list that were seperated in mergesort
	 * 
	 * @param SList
	 *            p1, SList p2
	 * @return SList
	 */
	public static <T extends Comparable<T>> SList<T> mergeHelper(
			SList<T> list1, SList<T> list2) {
		if (length(list1) == 0) {
			return list2;
		}
		if (length(list2) == 0) {
			return list1;
		}

		if (first(list1).compareTo(first(list2)) < 0) {
			SList<T> sorted = mergeHelper(rest(list1), list2);
			sorted = cons(first(list1), sorted);
			return sorted;
		} else {
			SList<T> sorted = mergeHelper(rest(list2), list1);
			sorted = cons(first(list2), sorted);
			return sorted;
		}
	}

	/**
	 * Performs the classic quicksort, claimed to be the fastest in its class.
	 * Whereas mergesort is topological, quicksort is sensitive to the values in
	 * the collection to be sorted.
	 * 
	 * @param list
	 * @return SList
	 */
	public static <T extends Comparable<T>> SList<T> qSort(SList<T> list) {
		if (length(list) == 0) {
			return list;
		}
		T pivot = first(list);
		SList less = SList.list(NULL);
		less = rest(less);
		SList greater = SList.list(NULL);
		greater = rest(greater);
		return partition(rest(list), pivot, less, greater);

	}

	/**
	 * Parition uses the first element of the list as a pivot and seperates the
	 * original list into lists either greater or less than the pivot
	 * 
	 * @param list
	 * @return SList
	 */
	public static <T extends Comparable<T>> SList<T> partition(SList<T> list,
			T pivot, SList<T> less, SList<T> greater) {
		if (length(list) == 0) {
			return append(qSort(less), cons(pivot, qSort(greater)));
		} else {
			if (first(list).compareTo(pivot) < 0) {
				less = cons(first(list), less);
				list = rest(list);
				return partition(list, pivot, less, greater);
			} else {
				greater = cons(first(list), greater);
				list = rest(list);
				return partition(list, pivot, less, greater);
			}
		}
	}

	/**
	 * Helper method reverse addsthe elements of list 1 to list2. Used in this
	 * case to reverse the list if list2 is empty
	 * 
	 * @param list
	 * @return SList
	 */
	public static <T> SList<T> reverse(SList<T> list1, SList<T> list2) {
		if (length(list1) == 0) {
			return list2;
		} else {
			list2 = cons(first(list1), list2);
			list1 = rest(list1);
			return reverse(list1, list2);
		}
	}
}